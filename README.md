# Spring User Banking

**Spring User Banking** – это RESTful-приложение, разработанное на базе **Java 11** и **Spring Boot** с учётом заданных бизнес-требований (**ТЗ**). Проект реализует управление пользовательскими данными, безопасную аутентификацию (JWT), банковские переводы и периодический пересчёт баланса.

## Краткое содержание

- [Spring User Banking](#spring-user-banking)
  - [Краткое содержание](#краткое-содержание)
  - [Основные возможности](#основные-возможности)
  - [Технологический стек](#технологический-стек)
  - [Обоснование ключевых решений по ТЗ](#обоснование-ключевых-решений-по-тз)
  - [Архитектура и структура кода](#архитектура-и-структура-кода)
  - [Сборка и запуск](#сборка-и-запуск)
    - [1. Локальный запуск (без Docker)](#1-локальный-запуск-без-docker)
    - [2. Запуск с помощью Docker Compose](#2-запуск-с-помощью-docker-compose)
    - [Настройки окружения](#настройки-окружения)
  - [Управление миграциями](#управление-миграциями)
  - [Документация API (Swagger)](#документация-api-swagger)
  - [Безопасность и аутентификация](#безопасность-и-аутентификация)
  - [Периодическое обновление баланса](#периодическое-обновление-баланса)
  - [Git Hooks](#git-hooks)
  - [Вопросы для дальнейшего уточнения](#вопросы-для-дальнейшего-уточнения)
  - [Приложение: Выписка из ТЗ](#приложение-выписка-из-тз)

----

## Основные возможности

- **Управление данными пользователей**  
  Хранение и обновление контактных данных (email, телефон), а также личных счетов (Accounts).

- **Безопасная аутентификация**  
  Используется Spring Security с JWT-токенами для авторизации запросов.  

- **Финансовые переводы**  
  Переводы между счетами с валидацией и проверкой доступности средств (баланс не может уйти в минус).  

- **Периодический пересчёт (scheduler)**  
  Каждые 30 секунд баланс каждого клиента увеличивается на 10%, но не может превышать 207% от изначального депозита.

- **Кэширование**  
  Redis используется для хранения ряда данных (в частности, начального баланса), что обеспечивает быструю доступность при соблюдении требований ТЗ.

- **Интеграционные тесты**  
  Использование Testcontainers для поднятия контейнеров (PostgreSQL) в процессе тестирования.

----

## Технологический стек

- **Java:** 11  
- **Spring Boot:** 2.7.18  
- **Spring Security:** Защита API и JWT  
- **PostgreSQL:** Основная СУБД (хранение пользователей, аккаунтов, email, телефонов)  
- **Redis:** Кэш-хранилище (в частности, для «начального баланса»)  
- **Flyway:** Миграции схемы БД  
- **Maven:** Система сборки  
- **Testcontainers:** Интеграционное тестирование в контейнерах  
- **Lombok:** Упрощение кода

**Дополнительно**  

- **Swagger 2 (Springfox):** Генерация документации REST API  
- **Docker/Docker Compose:** Контейнеризация и удобный запуск окружения (Postgres, Redis, Spring-приложение)

----

## Обоснование ключевых решений по ТЗ

В процессе реализации мы придерживались заданных в ТЗ требований, а также в ряде мест делали выбор:

1. **Выбор JDBC Template вместо ORM**  
   - **Почему?** ТЗ указывает на необходимость потоко-безопасных транзакций и детального контроля над запросами. Для нас важны параметризованные запросы и защита от SQL-инъекций. С `JdbcTemplate` мы имеем гибкий контроль и при этом остаёмся в рамках Spring Data. 

2. **Redis для хранения начального баланса**  
   - **Почему?** В ТЗ (п. «начальный баланс») прямо не регламентировалось хранить эту информацию в БД, но оговаривалась возможность использовать внешние хранилища (Redis/Elastic). Мы решили **не менять структуру БД** и вынести некоторые данные в Redis: это соответствует требованиями ТЗ и увеличивает производительность.

3. **Elastic Search**  
   - **Почему не внедрили?** В ТЗ упоминался Elasticsearch, однако не были указаны конкретные сценарии нагрузочного профиля и объёмы данных. Для текущих размеров и фильтрации достаточно индексирования в PostgreSQL. Elasticsearch сочли избыточным решением до появления реальной «Big Data».

4. **CI на GitHub Actions**  
   - **Почему?** В ТЗ говорится о сборке Maven, мы дополнили это быстрой CI-интеграцией на GitHub Actions – он проверяет, что приложение собирается при каждом коммите в main.

5. **Scheduler**  
   - **Почему именно так?** Текущая реализация (каждые 30 секунд) соответствует ТЗ. При значительном росте объёмов (десятки тысяч операций) возможно «окно» повышенной нагрузки. Тогда стоит распределять обновления по времени, чтобы, например при использовании автоматически масштабируемых облачных решений избежать лишних расходов.

----

## Архитектура и структура кода

Репозиторий организован по слоям: **controller** → **service** → **dao** → **model**.  
Ниже представлена укрупнённая структура:

```
spring-user-banking/
├── .github/
│   └── workflows/
│       └── ci-java.yml                # Конфигурация CI (GitHub Actions)
├── hooks/
│   └── prepare-commit-msg             # Скрипт-хук для автоматизации расстановки префиксов в заголовки коммитов
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/example/spring_user_banking/
│   │   │       ├── config/
│   │   │       │   ├── database/
│   │   │       │   │   └── DatabaseConstants.java
│   │   │       │   ├── RedisConfig.java
│   │   │       │   ├── SecurityConfig.java
│   │   │       │   └── SwaggerConfig.java
│   │   │       ├── controller/
│   │   │       │   ├── AccountController.java
│   │   │       │   ├── AuthController.java
│   │   │       │   └── UserController.java
│   │   │       ├── dao/
│   │   │       │   ├── impl/
│   │   │       │   │   ├── AccountDaoPostgresImpl.java
│   │   │       │   │   ├── EmailDataDaoPostgresImpl.java
│   │   │       │   │   ├── PhoneDataDaoPostgresImpl.java
│   │   │       │   │   └── UserDaoPostgresImpl.java
│   │   │       │   ├── AccountDao.java
│   │   │       │   ├── EmailDataDao.java
│   │   │       │   ├── PhoneDataDao.java
│   │   │       │   └── UserDao.java
│   │   │       ├── dto/
│   │   │       │   ├── AuthRequest.java
│   │   │       │   ├── EmailDTO.java
│   │   │       │   ├── PhoneDTO.java
│   │   │       │   ├── TransferRequestDTO.java
│   │   │       │   └── UserDTO.java
│   │   │       ├── exception/
│   │   │       │   ├── CustomException.java
│   │   │       │   ├── GlobalExceptionHandler.java
│   │   │       │   └── UnauthorizedException.java
│   │   │       ├── mapper/
│   │   │       │   └── UserMapper.java
│   │   │       ├── model/
│   │   │       │   ├── Account.java
│   │   │       │   ├── EmailData.java
│   │   │       │   ├── PhoneData.java
│   │   │       │   └── User.java
│   │   │       ├── scheduler/
│   │   │       │   └── BalanceUpdateScheduler.java
│   │   │       ├── security/
│   │   │       │   ├── JwtAuthFilter.java
│   │   │       │   ├── JwtTokenProvider.java
│   │   │       │   └── SimpleAuthToken.java
│   │   │       ├── service/
│   │   │       │   ├── AuthService.java
│   │   │       │   ├── BonusService.java
│   │   │       │   ├── TransferService.java
│   │   │       │   └── UserService.java
│   │   │       └── SpringUserBankingApplication.java
│   │   └── resources/
│   │       ├── application.properties
│   │       ├── db/
│   │       │   └── migration/
│   │       │       │   └── V1_initial_setup.sql
│   │       └── logback.xml
│   └── test/
│       └── java/
│           └── com/example/spring_user_banking/
│               ├── controller/
│               │   └── AccountControllerIntegrationTest.java
│               ├── service/
│               │   └── TransferServiceTest.java
│               └── SpringUserBankingApplicationTests.java
├── .gitattributes
├── .gitignore
├── docker-compose.yml
├── Dockerfile
├── pom.xml
└── README.md
```

----

## Сборка и запуск

### 1. Локальный запуск (без Docker)

Убедитесь, что у вас установлен PostgreSQL и Redis, а в `application.properties` прописаны корректные настройки подключения к внешним сервисам.

```bash
# Установка зависимостей и сборка
mvn clean install

# Запуск приложения
mvn spring-boot:run
```

После запуска приложение будет доступно по адресу `http://localhost:8080`.

### 2. Запуск с помощью Docker Compose

В репозитории имеется готовый `docker-compose.yml`, позволяющий поднять три контейнера: **app**, **postgres**, **redis**.

1. **Соберите и запустите все контейнеры** в фоне:

   ```bash
   docker-compose up --build -d
   ```

2. **Просмотр логов**:

   ```bash
   docker-compose logs -f app
   ```

3. **Перезапуск приложения** (не трогая базу):

   ```bash
   docker-compose restart app
   ```

4. **Остановка и удаление всех контейнеров**:

   ```bash
   docker-compose down
   ```

### Настройки окружения

По умолчанию в `docker-compose.yml` используются следующие переменные окружения:
- `SPRING_DATASOURCE_URL`, `SPRING_DATASOURCE_USERNAME`, `SPRING_DATASOURCE_PASSWORD`
- `SPRING_REDIS_HOST`, `SPRING_REDIS_PORT`
- `JWT_SECRET`, `JWT_EXPIRATION`

При необходимости их можно переопределять через `.env` или напрямую передавая в командную строку.

----

## Управление миграциями

В проекте используется **Flyway** для автоматического применения миграций к PostgreSQL при старте приложения.

- Все SQL-миграции расположены в `src/main/resources/db/migration`.  
- Конфигурация Flyway задаётся в `application.properties` (параметры `spring.flyway.*`).  

----

## Документация API (Swagger)

Для описания REST API используется Springfox (Swagger 2).

- Интерфейс доступен по адресу:

  ```
  http://localhost:8080/swagger-ui.html
  ```

- Версия библиотеки – **2.9.2**, которая имеет известные уязвимости (например, CVE-2019-17495).  
  Рекомендуется перейти на более современный стек (Springdoc/OpenAPI) для продакшена. (как вариант, из продовой версии можно эту зависимость просто удалить)

**Важная настройка:**  
При использовании Spring Boot 2.7+ может потребоваться добавить в `application.properties`:

```properties
spring.mvc.pathmatch.matching-strategy=ant_path_matcher
```

Это обеспечивает совместимость Springfox c текущими версиями Spring.

----

## Безопасность и аутентификация

- **JWT**  
  Аутентификация основана на выдаче JWT-токена при логине (см. `AuthController`).  
  Токен формируется в `JwtTokenProvider` и проверяется в `JwtAuthFilter`.  

- **Spring Security**  
  С помощью `SecurityConfig` настраиваются фильтры и роуты, требующие авторизации.  
  По умолчанию большинство эндпоинтов доступны только после аутентификации.

----

## Периодическое обновление баланса

Класс `BalanceUpdateScheduler` (Spring Scheduler) отвечает за плановые задачи по обновлению баланса (например, начисление бонусов).

- Периодичность запуска (30 секунд) выбрана согласно ТЗ.  
- Алгоритм увеличения: +10% от текущего баланса до тех пор, пока итог не превысит 207% от **начального** депозита.  
- В распределённой среде важно убедиться, что задача не запускается в нескольких экземплярах одновременно (Leader Election, Redis Lock и пр.).  

При росте масштабов (десятки тысяч пользователей) возможны провисания при одновременном пересчёте. Следует либо распределять обновления по времени, либо использовать более продвинутые механизмы.

----

## Git Hooks

В директории [`hooks`](./hooks) находится настраиваемый хук Git `prepare-commit-msg`, который:

- Автоматически добавляет название текущей ветки в начало сообщения коммита.
- Обеспечивает единообразное ведение истории.

Чтобы активировать хук:

```bash
git config core.hooksPath hooks
chmod +x hooks/prepare-commit-msg
```

Убедитесь, что у скрипта есть права на исполнение.

----

## Вопросы для дальнейшего уточнения


1. **Транзакции**  
   - JDBC Template даёт точечный контроль, но при дальнейшем усложнении бизнес-логики может понадобиться более сложный механизм (саги / распределённые транзакции).  
2. **Согласованность данных**  
   - Нужно ли логировать или аудировать каждую операцию банковского перевода (для регуляторов и/или аудита)?  
3. **Использование Redis**  
   - Какие ещё данные можно кэшировать (кроме начального баланса)? Нужно ли хранить сессии/токены для принудительного логаута?  
4. **Масштабирование**  
   - При значительном росте нагрузки потребуется распределение вычислений планировщика и, возможно, переход на Kubernetes/Swarm с подключением централизованных сервисов (конфигурация, балансировщик и пр.).  
5. **Java 17+**  
   - Рассматривается ли обновление до более новой LTS-версии для улучшения безопасности, поддержки новых конструкций языка?

----

## Приложение: Выписка из ТЗ

> **Выдержки из ТЗ (сокращённо):**
> - **Стек:** PostgreSQL, Redis/Elastic (по необходимости), Java 11, Spring Boot, Maven.  
> - **Обязательные слои**: API, Service, DAO.  
> - **Пользователи** создаются миграциями, без UI для создания.  
> - **Телефонов и email** может быть несколько на одного пользователя, как минимум по одному.  
> - **Account** один на пользователя, баланс не уходит в минус.  
> - **Баланс** изначально задаётся при создании пользователя и может расти каждые 30 секунд на 10%, но не более 207% от первоначального.  
> - **JWT**: Авторизация по email+password или phone+password.  
> - **Операции с данными**: редактирование контактной информации, транзакции между пользователями.  
> - **Swagger**: желательно для минимальной документации.  
> - **Логирование**: разумный уровень логов для ключевых операций.  
> - **Testcontainers** и интеграционные тесты.  

----
